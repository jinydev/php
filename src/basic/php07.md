---
layout: php
title: "PHP"
keyword: "jinyphp, php"
---
## 연산자

연산의 개념은 초등학교부터 자연스럽게 학습했습니다. 더하기, 빼기 등 산술 연산은 어려서부터 공부를 했습니다.

컴퓨터의 발전과 프로그램의 역사는 이 기본적인 수학적 연산을 하기 위해서 발전하였습니다. 그리고 이러한 수학적 표현과 연산법을 좀 더 쉽게 프로그래밍을 하기 위해서 다양한 프로그램 언어들로 진화한 것입니다.

연산 작업은 컴퓨터의 가장 기초적인 동작과 근본이 되는 개념입니다. 하지만 이를 너무 쉽게 생각하고 건너뛰거나 개략적인 부분만 이야기를 한 것 같습니다. 이번 장에서는 좀 더 심화된 연산과 이와 관련된 연산 기법들을 살펴보도록 하겠습니다.

프로그램 언어에서의 연산은 기본적인 덧셈, 뺄셈과 같은 산술 연산 이외에 다양한 연산 처리를 합니다. 우리가 학년이 올라가서 산수에서 수학의 개념으로, 집합 및 대수의 비교 등 컴퓨터가 처리할 수 있는 연산들은 다음과 같습니다.

PHP에서는 다음과 같은 연산기능과 기호를 제공합니다.

●	산술 연산
●	복합 대입 연산
●	비교 연산 
●	증가/감소 연산자
●	논리 연산자
●	문자열 연산자
●	배열 연산자

위의 연산들은 우리가 잘 알고 있는 수학적인 기호를 사용하지만 일부 기호들은 좀 더 컴퓨터적인 측면으로 처리되는 부분도 있습니다.


7.1 = 대입 연산자

일반적으로 우리가 수학에서 알고 있는 = 기호는 다항식, 방정식 등에서 서로 같다’라는 의미로 알고 있습니다.

1 + 1 = 2

x + 2 = y

위의 표현 처럼 = 기호는 왼쪽에는 수식을 입력하고 결과를 오른쪽에 표시하는 데 익숙할 것입니다. 그러나 컴퓨터 프로그램 언어에서는 수학에서 표시하는 방법과는 반대로 좌우가 바뀌어 있습니다.

2 = 1 + 1

y = x  + 2 


대부분의 컴퓨터 프로그램 언어에서는 좌측의 값은 우측의 값과 같다라고 표현합니다.

 


7.1.1 대입의 의미
프로그램 언어에서는 =를 ‘같다’는 의미의 또 다른 의미로 ‘대입’이라고 표현합니다. 이것은 컴퓨터 시스템의 메모리등의 컨셉이 기존 수학적 개념과 약간 달리 표현하기 때문입니다.
결국 대입한다는 것은 좌측의 값과 우측의 값이 같다는 의미로도 생각할 수 있습니다.

|문법|)
$a = $b;
$a = $b +2;

위의 기본 문법을 보면 변수 $b의 값을 $a에 값을 대입하여 저장한다는 의미입니다.

컴퓨터에서는 값이 같다라는 표현보다 똑 같은 값을 ‘저장한다’ 라는 표현이 더 정확할 지도 모르겠습니다. 우측의 값을 연산하여 좌측의 변수에 저장을 하기 때문에 서로의 값은 같기도 하면서 대입하여 저장이 된다고도 표현할 수 있을 것입니다.


7.1.2 다양한 대입 응용
대입 연산자는 수식에서만 사용하지 않고 문자열에도 사용 가능합니다. 이런 표현이 가능한 것은 = 기호를 ‘같다’라는 의미보다 대입, 저장한다 라는 의미로 받아 들이기 때문입니다.

|문법|
$a = “hello world!”;

$a에 문자열 “hello world!”를 대입하면 좌측의 $a와 “hello world!” 은 같은 값이 되는 것입니다.

대입 연산자는 프로그램 가장 기본적이고 향후우에 다루어 지는 모든 소스, 다루어지는 함수, 클래스 인스턴스 등 다양한 문법에도 사용을 합니다. 

함수 대입 예제)
$i = intval($val);

위의 예제표현은 함수의 결과값을 $i에 저장을 하기 때문에 서로 같은 것입니다.

클래스 대입 예제)

$obj = new jiny;

위의 예제표현은 클래스의 오브젝트를 생성하여 저장하는 예 입니다. 저장을 했기 때문에 대입연산자 = 를 사용한 것입니다.


7.1.3 call by value
대입 연산자 = 기호는 같다의 또 다른 의미로 우측의 값을 좌측으로 넣는다고 했습니다. 대부분의 변수 데이터는 메모리 안에 값이 저장이 됩니다. 언어에서 아래와 같은 표현은 

|문법|
$a = $b;

$b의 메모리 값을 $a의 메모리에 값을 복사하는 것과 같습니다.

대입은 좀 더 실제적인 의미는 우측의 값을 좌측으로 저장, 즉 복사를 하는 것과 같습니다. 이것은 프로그램에서 변수를 정의하거나 생성하면 각각의 메모리 공간이 생성됩니다.


 

이렇게 메모리 값을 직접 저장하는 방식의 데이터 처리 유형을 call by value라고 합니다. 말 그대로 값을 호출한다 입니다.call by value는 실제적인 값이 변수에 저장되어 전달됩니다.

앞으로도 대입 연산자는 많은 소스와 예제를 통해 다양한 활용법을 학습할 수 있을 것입니다.

7.2 =, & 참조

대입 연산자를 call by value 방식으로 값을 복사하는 것에 대해 학습했습니다. 좀 더 심화적으로 컴퓨터의 내부를 들여다 본다면 대입연산자는 한가지 더 또다른 의미를 부여할 수 있습니다. 바로 참조 대입이라는 것입니다. 컴퓨터 언어에서 일반적인 = 대입 연산자 이외에 참조라는 새로운 대입 연산자가 존재합니다.


7.2.1 메모리 주소
참조라는 개념을 이해하기 위해서는 컴퓨터 구조 및 메모리 시스템에 대해서 좀 더 추가적인 이해가 필요합니다.

컴퓨터를 구매할 때 메모리가 8G, 16G, 32G 등 용량을 표시합니다. 실제적으로 컴퓨터는 수많은 메모리 공간을 가지고 있으며 각각의 메모리 저장소 하나하나는 고유의 번호가 존재합니다.

 

호텔에서 수많은 방 앞에 번호를 붙여 놓은 것처럼 말입니다.

앞에서 = 대입 연산자의 경우에는 변수명만으로 프로그램 처리를 했습니다.했으나, 참조는 변수명과 함께 방 번호와 같이 메모리의 번호로도 같이 이용하는 개념입니다.

  
7.2.2 call by reference
참조 대입 연산자는 =와 &를 결합한 =&로 표시합니다.

|문법|
$a = &$b;

위의 표현은 $a 변수에 $b 값을 저장하는 것이 아니라 $b가 저장되어 있는 메모리 주소를 전달하는 것입니다.

메모리의 주소를 복사하게 되면 $a와 $b는 같은 메모리 공간을 가리키며 $a와 $b로 동일한 메모리의 공간에 값을 저장하거나 읽어올 수 있습니다.
 

그럼 예제를 참고하여 실제적인 동작을 학습해보겠습니다.

다음 예제는 참조를 통해 메모리 주소를 복사해보는 예제입니다. 

예제 파일 callbyr-01.php
<?php
	$a = 123;
	echo "a 값입니다 = ". $a ."<br>";

	$b = &$a;
	echo "b 값입니다 = ". $b."<br>";
?>

결과
a 값입니다 = 123
b 값입니다 = 123

위의 예제를 보면 변수 $a는 정수 값 123을 가지고 있습니다. 그리고 변수 $b는 변수 $a의 참조(방번호 주소값) 값을 변수 $b에 대입하게 됩니다. 

변수 $b는 메모리의 저장 위치 값으로 $a를 가리킵니다. 즉 같은 호텔방의 번호를 가리키는 것과 같습니다. 방 키를 두 개로 복사한 것이죠.

다음 예제는 메모리를 복사한 후에 복사된 변수에 새로운 값을 저장해봅니다. 또한 원 변수의 값이 어떻게 처리되는지 확인해보겠습니다.

예제 파일 callbyr-02.php
<?php
	$a = 123;
	echo "a 값입니다 = ". $a ."<br>";

	$b = &$a;
	echo "b 값입니다 = ". $b."<br>";

	$b = "abcd";
	echo "a 값입니다 = ". $a."<br>";
?>

결과
a 값입니다 = 123
b 값입니다 = 123
a 값입니다 = abcd

두 번째 예는 $b는 $a와 똑같은 메모리 방 번호를 가리키고 있습니다. 즉, 복사된 방 키입니다.

$b에 문자열 “abcd”를 대입을 하고, $a의 값을 출력해봅니다. $a의 값은 $b가 입력한 값과 같은 것을 확인할 수 있습니다.

이렇게 변수의 메모리 주소를 전달하여 데이터를 처리하는 방식을 call by reference라고 합니다. 


7.2.3 &
& 기호는 변수의 메모리 주소를 표현하는 기호입니다. 변수명 앞에 & 기호가 붙게 되면 해당 변수의 메모리 주소 값을 나타냅니다.

이는 C 언어에서 많이 사용하는 포인터와 비슷한 개념입니다. C 언어에서는 * 기호를 사용했지만 PHP에서는 &를 사용합니다.

 

7.3 산술 연산자

산술 연산이란 일반적으로 숫자를 기준으로 더하거나 빼기, 곱하기, 나누기 등 사칙 연산을 말합니다. 사칙 연산은 프로그램의 가장 기본적인 연산 기호입니다.


7.3.1 더하기
컴퓨터 언어의 덧셈 기호는 +를 사용합니다.
 
덧셈은 좌우의 값을 합산한 값을 출력합니다. 또한 합산한 결과값을 왼쪽에 대입 연산자를 통해 변수에 저장할 수 있습니다.

|문법|
$sum = 1 + 2 + 3 + 3.14;

숫자 값을 직접 입력하여 덧셈을 처리할 수 있습니다.

$sum = $a + 3.14;

변수와 숫자 값을 이용하여 덧셈을 처리할 수 있습니다.

$sum = $x + $y

변수와 변수 값만으로 덧셈을 처리할 수 있습니다.


7.3.2 빼기
컴퓨터 언어의 뺄셈 기호는 -를 사용합니다.

뺄셈은 좌측의 값에서 우측의 값을 뺀 값을 출력합니다. 또한 뺄셈한 결과값을 왼쪽에 대입 연산자를 통해 변수에 저장할 수 있습니다.

|문법|
$sum = $x - $y

컴퓨터는 CPU에 연산을 담당하는 ALU라는 반도체 로직이 설계되어 있습니다. 컴퓨터의 연산은 기본적으로 덧셈을 기준으로 설계를 합니다.

뺄셈은 즉 오른쪽의 값을 음수로 변환하여 덧셈을 하는 것과 비슷합니다.

$sum = $x + (- $y)

빼고자 하는 값의 데이터 부호 비트를 변경하여 덧셈을 처리하는 것이 뺄셈의 원리입니다.

이러한 하드웨어적인 처리는 단일 설계로 덧셈과 뺄셈을 함께 할 수 있는 설계 기술입니다. 이러한 점을 프로그램 코딩 시 이해하면 보다 다양한 계산 로직을 만들어낼 수 있을 것입니다.


7.3.3 곱하기
컴퓨터 언어의 곱셈 기호는 *를 사용합니다. 우리가 일반적으로 알고 있는 ×를 사용하지 않습니다.

곱셈은 좌우의 값을 곱한 값을 출력합니다. 또한 곱한 결과값을 왼쪽에 대입 연산자를 통해 변수에 저장할 수 있습니다.

|문법|
$sum = $x * $y

$a = 5 * 3; → $ = 5 + 5 + 5;


위와 같은 곱셈은 왼쪽에 있는 값을 오른쪽의 값의 횟수만큼 더한 값과 같습니다.

$ = 5 + 5 + 5;

즉 세 번의 덧셈을 처리하는 것과 같습니다.

예제 파일 mul-01.php
<?php

	$x = 5;
	$y = 3;

	$sum = 0;
	for ($i=0;$i<$y;$i++) {
		$sum = $sum + $x;
	}

	echo "곱셈은 덧셈의 반복 = ". $sum ;
?>

결과
곱셈은 덧셈의 반복 = 15


7.3.4 나누기
컴퓨터 언어의 나눗셈 기호는 백슬레쉬(/)를 사용합니다. 우리가 일반적으로 사용하는  ÷를 쓰지 않습니다.

나눗셈은 좌측의 값에서 우측의 값을 나눈 값을 출력합니다. 또한 나눗셈한 결과값을 왼쪽에 대입 연산자를 통해 변수에 저장할 수 있습니다.

|문법|
$sum = $x / $y

예제 파일 div-01.php
<?php
	$a = 10 / 3;
	echo "나눗셈 10 / 3 = ".$a;
?>

결과
나눗셈 10 / 3 = 3.3333333333333

PHP의 변수는 타입이 자유롭기 때문에 나눗셈을 처리한 $a 변수는 실수타입으로 출력이 됩니다.

만일 나누기의 몫을 계산을 하기 위해서는 출력결과값을 정수로 변환하여 값을 가지고 올 수 있습니다.

예제 파일 div-02.php

<?php

	$a = 10 / 3;
	echo "나눗셈 10 / 3 = ".$a;
	echo "<br>";
	echo "나누기의 몫 = ". intval($a);
?>

결과
나눗셈 10 / 3 = 3.3333333333333
나누기의 몫 = 3

나누기 또한 곱셈과 비슷하게 좌측의 값을 오른쪽의 값으로 반복적으로 뺄셈을 반복하는 것과 같습니다. 뺄셈을 반복하면서 결과값이 빼고자 하는 값보다 크면 반복을 하고, 작으면 반복을 중단합니다.

반복한 횟수를 몫으로 표기하고 더 이상 뺄셈을 반복을 할 수 없는 조건으로 값이 뺄셈보다 작은 값을 가질 때 나머지로 합니다.

예제 파일 div-03.php
<?php
	$x = 10;
	$y = 3;
	echo "x = $x <br>";

	$div = 0;
	for ($i=0;$i<$x;$i++) {
		if ($x>=$y) {
			$x = $x - $y;
			$div = $div + 1;

			echo "x = $x , div = $div <br>";

		} else {
			echo "x < y 보다 작습니다. 반복문 탈출";
			break;
		}
		
	}

	echo "나누기 몫 = ". $div . ", 나머지 = " . $x;
?>

결과
x = 10
x = 7 , div = 1
x = 4 , div = 2
x = 1 , div = 3
나누기 몫 = 3, 나머지 = 1

위의 예는 나눗셈의 원리를 프로그램 코딩한 것입니다. 10을 3으로 나누는 것은 먼저 10에서 3을 뺄셈을 합니다. 그 결과가 3보다 크면 못을 1을 더하고 또다시 결과값에서 3을 뺄셈합니다. 결과값이 3보다 작을 때까지 이 동작을 반복하면 됩니다. 만일 결과값이 3보다 작을 때 그 값은 나머지가 됩니다.

7.3.5 나머지
컴퓨터는 프로그램 언어는 일반적인 사칙 연산 네 가지 이외에 나누기의 나머지를 계산할 수 있는 특수한 기호를 제공합니다.

앞서 나눗셈을 원리를 풀어서 코딩한 것을 보면은 나머지를 구하는 공식은 그다지 간단하지 않습니다. 하지만 PHP 언어에서는 나머지를 쉽게 구할 수 있는 연산기호를 제공합니다.

% 기호는 나누기 연산의 몫이 있을 때 값을 반환합니다. 결과값을 왼쪽에 대입 연산자를 통해 변수에 저장할 수 있습니다.

|문법|
나머지의 연산 방법 $sum = $x % $y

% 기호를 통해 $x에 대한 $y의 나머지를 계산할 수 있습니다.
 예제 파일 div-04.php
<?php
	$a = 10 % 3;
	echo "나누기 몫 = " . $a;
?>

결과
나누기 몫 = 1

나누기의 몫(%)을 잘 이용하면 홀수/짝수 등 특정 숫자의 배수를 계산할 수 있습니다.

 예제 파일 div-05.php
<?php
	$x = 10;
	$even = 2;
	$y = 3;

	echo "x = $x <br>";

	for ($i=1;$i<$x;$i++) {
		if ($i%$even) {
			echo "x = $i 는 홀수입니다.<br>";			
		} else {
			echo "x = $i 는 짝수입니다.<br>";
		}

		if ($i%$y) {
			echo "x = $i 는 3의 배수 아닙니다.<br>";			
		} else {
			echo "x = $i 는 3의 배수입니다.<br>";
		}
		
	}

?>

결과
x = 10
x = 1 는 홀수입니다.
x = 1 는 3의 배수 아닙니다.
x = 2 는 짝수입니다.
x = 2 는 3의 배수 아닙니다.
x = 3 는 홀수입니다.
x = 3 는 3의 배수입니다.
x = 4 는 짝수입니다.
x = 4 는 3의 배수 아닙니다.
x = 5 는 홀수입니다.
x = 5 는 3의 배수 아닙니다.
x = 6 는 짝수입니다.
x = 6 는 3의 배수입니다.
x = 7 는 홀수입니다.
x = 7 는 3의 배수 아닙니다.
x = 8 는 짝수입니다.
x = 8 는 3의 배수 아닙니다.
x = 9 는 홀수입니다.
x = 9 는 3의 배수입니다.

위의 예제는 2의 배수나 3의 배수 등 나머지가 0이 된다는 것은 배수이고, 아닌 것은 배수가 아니라는 나머지의 특성을 가지고 작성한 예제 소스입니다. 

7.4 연산자 우선순위

연산자 우선순위는 어릴 적 사칙 연산과 더불어 우선순위도 같이 학습했습니다. 컴퓨터 프로그래밍 언어에서도 이와 같은 연산자의 우선순위를 따릅니다.

우선순위는 여러 개의 연산자를 복합적으로 사용할 때 순서대로 처리하는 것이 아니라 연산 속성에 따라서 먼저 처리를 해야 하는 순서입니다.

보통 연산자는 좌측에서 우측으로 처리합니다. 

연산자 우선순위는 너무 기초적인 부분이라고 생각들지만 막상 계산기 같은 프로그램을 만들다 보면 우선순위를 정확하게 정의하지 못하여 오류 계산이 발생하곤 합니다.


7.4.1 우선순위 결합 위치
●	1 	++ --	무결합 
●	2 	!	오른쪽부터
●	3 	* / %	왼쪽부터
●	4 	+ - .	왼쪽부터
●	5 	<< >>	왼쪽부터
●	6 	< <= > >= <>	무결합 
●	7 	== != === !==	무결합 
●	8 	&	왼쪽부터
●	9 	^	왼쪽부터
●	10 	|	왼쪽부터
●	11 	&&	왼쪽부터
●	12 	||	왼쪽부터
●	13 	? :	왼쪽부터
●	14 	= += -= *= /= .= %= &= |= ^= <<= >>=	오른쪽부터
●	15 	and	왼쪽부터
●	16 	xor	왼쪽부터
●	17 	or	왼쪽부터
●	18 	,	왼쪽부터


7.4.2 덧셈과 뺄셈
$a = 1 - 2 + 3 - 4 + 5;
$a = $b - 2 + $c - 4+ 5;

덧셈(+) 과 뺄셈(-)은 같은 연산자 우선순위를 가지고 있습니다. 좌측에서 우측 방향으로 계산을 처리합니다.

 

7.4.3 곱셈과 나눗셈
곱셈(*)과 나눗셈(/)은 덧셈과 뺄셈보다 우선합니다.

$a = 7 + 7 / 7 + 7 * 7 - 7;
$a = 13 + 25.3 * 6 / $n;

좌측에서 우측으로 연산하기에 앞서 곱셈과 나눗셈이 나타나면 우선적으로 처리합니다.

 


7.4.4 괄호
각각의 연산자는 우선순위를 가지고 있습니다. 하지만 연산자의 우선순위를 바꾸기 위한 방법으로 괄호( )를 사용합니다.

연산 수식에서 괄호가 있으면 제일 우선적으로 처리합니다.

예제)
$value = (12.0 + 25.3) * $abc / $two;
$count = -(2+5)*7 + (5 + 3 * (2 +3));

 

중괄호가 중첩될 경우에는 안쪽의 괄호가 우선적으로 처리됩니다.

7.4.5 우선순위 예제

다음 예제는 조건문에서의 연산자 우선 순위를 실험하는 예입니다.

예제 파일 op-0130.php
 <?php

 	// >는 == 보다 우선순위입니다.
 	// 1>2 false입니다.
 	// 숫자 2는 true입니다.
 	if (1 > 2 == 2) {  
    		echo "두 개의 논리는 같습니다.<br>";  
 	} else {
 		echo "두 개의 논리는 틀립니다.<br>";  
 	}
 
 	// < 는 ==보다 우선순위입니다.
 	// 1 < 2 는 true입니다.
 	// 숫자 2는 true입니다.
	if (2 == 1 < 2) {   
    		echo "두 개의 논리는 같습니다.<br>";   
	} else {
		echo "두 개의 논리는 틀립니다.<br>"; 
	}

 ?>


결과
두 개의 논리는 틀립니다.
두 개의 논리는 같습니다.

위의 예제에서 첫 번째 조건 1 > 2 == 2 는,  >는 == 보다 우선순위 입니다. 먼저 1>2 를 비교합니다. 결과는 거짓(false) 입니다. 그리고 숫자 상수 2는 참(true) 입니다. 즉 조건문은 false == true를 비교하는 것입니다.

두 번째 조건 2 == 1 < 2는, < 는 ==보다 우선순위입니다. 먼저 1<2를 비교합니다. 결과는 참(true)입니다. 그리고 숫자 상수 2는 참(true)입니다. 즉 조건문은 true == true를 비교하는 것입니다.

다음 예제는 또한 연산자 우선순위입니다.

예제 파일 op-0231.php
 <?php

 	$a = 1;  
 	$b = 2;

 	// = 는 + 보다 우선권을 가집니다. 
 	// $a = ($b += 3) 
 	$a = $b += 3;  
 	echo "a = $a, b = $b";
 	// 결과: $a = 5, $b = 5  
 ?>


결과)
a = 5, b = 5 

위의 예제를 보면 $a 는 값1, $b 는 값 2를 가지고 있습니다. 먼저 $b + 3 이 우선으로 실행됩니다. 그래서 $b의 값은 5가 됩니다. 우선 작업된 $b + 3의 값 5가 $a에 저장됩니다.

7.5 비교 연산자

비교란 2개의 값의 크기를 판별하여 상태값을 true/false 논리값으로 판단할 수 있는 연산자입니다.


7.5.1 동일 비교 연산자
동일 비교란 서로의 값이 같은지를 판별하는 것입니다. 

우리가 알고 있는 같다는 의미의 = 기호는 프로그램 언어에서 대입 연산자로 이미 사용을 하고 있습니다. 

따라서 프로그램 언어에서는 서로 같은지 판단하는 기호로 =를 두 번 표기한 ==로 사용합니다.


$x == $y

== 기호를 중심으로 좌우의 값이 같은 경우 참(true)을 반환하고, 같지 않은 겨우 거짓(false)을 나타냅니다.

예제 파일 op-0301.php
<?php
	$x = 123;
	$y = 123.0;

	if ($x == $y) {
		echo "x = y 는 같은 값입니다.";
	} else {
		echo "x = y 는 서로 틀립니다.";
	}

?>

결과
x = y 는 같은 값입니다.

== 기호는 프로그램의 조건문에서 가장 많이 사용하는 기호입니다.


7.5.2 타입값 비교
고전적인 프로그램 언어에서는 서로의 값을 비교하는 연산자 ==만 사용이 가능했습니다. 하지만 PHP는 확장된 비교 연산자 ===를 지원합니다.

= 기호를 세 번 연결한 === 기호는 변수의 값과 더불어 형 타입까지 비교하는 연산자입니다.
 
예제 파일 op-0402.php
<?php
	$x = 123;
	$y = 123.0;

	if ($x === $y) {
		echo "x === y 는 같은 값입니다.";
	} else {
		echo "x === y 는 서로 틀립니다.";
	}

?>

결과
x === y는 서로 틀립니다.

위의 예제 $x 는 123 값을 가지고 있는 정수형 타입입니다. 그리고 $y는 123.0으로 실수의 값을 가지고 있습니다. 수학적으로 값은 같을 수 있겠지만 타입으로는 정수와 실수로 다릅니다.

== 기호로는 정수든 실수든 값의 크기가 같기 때문에 참(false)을 출력하지만, === 기호로는 변수 타입까지 비교하기 때문에 거짓(false)을 반환합니다.


7.5.3 같지 않은 !
프로그램 언어에서는 느낌표(!)는 부정을 나타냅니다. 논리 기호 not 을 뜻합니다.

 

앞에서 배운 == 기호는 두 개의 값이 동일한지를 비교하는 연산자이지만 !를 앞에 붙이면 ‘같지 않은’ 조건을 판별할 수 있습니다.
 
예제 파일 op-0503.php
<?php
	$x = "hello";
	$y = "abcd";

	if ($x !== $y) {
		echo "x($x) !== y($y) 는 같은 값이 아닙니다.";
	} else {
		echo "x($x) !== y($y) 는 서로 같습니다.";
	}

?>


결과
x(hello) !== y(abcd)는 같은 값이 아닙니다.

!== 연산자 이외에 <> 기호를 사용할 수도 있습니다.

예제 파일 op-0605.php
<?php
	$x = 123;
	$y = 123;

	if ($x !== $y) {
		echo "x !== y 는 서로 틀립니다.";		
	} else {
		echo "x !== y 는 같은 값입니다.";
	}

	echo "<br>";
	
	if ($x <> $y) {
		echo "x <> y 는 서로 틀립니다.";		
	} else {
		echo "x <> y 는 같은 값입니다.";
	}

?>

결과
x !== y 는 같은 값입니다.
x <> y 는 같은 값입니다.

부정 표현은 값을 일치하지 않은 조건으로도 많이 사용하는 비교 연산자입니다.

7.5.4 > 크다
크기 비교 연산자는 우측의 값을 기준으로 판단합니다. 

 

> 기호는 우측 값보다 좌측 값이 클 때를 비교하는 연산자입니다.

예제 파일 op-0706.php
<?php
	$x = 123;

	if ($x > 120) {
		echo "$x 는 120보다 큰 값입니다.";		
	} else {
		echo "$x 크지 않습니다.";
	}

	echo "<br>";

	if ($x > 123) {
		echo "$x 는 123보다 큰 값입니다.";		
	} else {
		echo "$x 크지 않습니다.";
	}

?>

결과
123는 120보다 큰 값입니다.
123 크지 않습니다.

크다는 표현은 같은 값을 포함하지는 않습니다. 또한 항상 오른쪽이 기준값이 됩니다.


7.5.5 < 작다

크기 비교 연산자는 우측의 값을 기준으로 판단합니다.

 

< 기호는 우측의 값보다 좌측의 값이 작을 때를 비교하는 연산자입니다.

예제 파일 op-08.php
<?php
	$x = 123;

	if ($x < 150) {
		echo "$x 는 150보다 작은 값입니다.";		
	} else {
		echo "$x 작지 않습니다.";
	}

	echo "<br>";
	
	if ($x < 123) {
		echo "$x 는 123보다 작은 값입니다.";		
	} else {
		echo "$x 작지 않습니다.";
	}


?>


결과
123는 150보다 작은 값입니다.
123 작지 않습니다.

작다는 표현은 같은 값을 포함하지는 않습니다.


7.5.6 >= 크거나 같다
크기 비교 연산자는 우측의 값을 기준으로 판단합니다. > 기호는 우측의 값보다 좌측의 값이 클 때를 비교하는 연산자입니다.

 

크거나 같다는 표현은 같은 값을 포함하기 때문에 == 같은 값과 > 큰 값을 확인하는 두 가지 조건을 모두 포함합니다.

예제 파일 op-0907.php
<?php
	$x = 123;

	if ($x >= 120) {
		echo "$x는 120보다 큰 값입니다.";		
	} else {
		echo "$x 크지 않습니다.";
	}

	echo "<br>";

	if ($x >= 123) {
		echo "$x는 123보다 큰 값입니다.";		
	} else {
		echo "$x 크지 않습니다.";
	}

?>


결과
123는 120보다 큰 값입니다.
123는 123보다 큰 값입니다.


7.5.7 <= 작거나 같다 
크기 비교 연산자는 우측의 값을 기준으로 판단합니다. < 기호는 우측의 값보다 좌측의 값이 작을 때를 비교하는 연산자입니다.

 

작거나 같다는 표현은 같은 값을 포함하기 때문에 == 같은 값과 < 큰 값을 확인하는 두 가지 조건을 모두 포함합니다.

예제 파일 op-1009.php
<?php
	$x = 123;

	if ($x <= 150) {
		echo "$x는 150보다 작은 값입니다.";		
	} else {
		echo "$x 작지 않습니다.";
	}

	echo "<br>";
	
	if ($x <= 123) {
		echo "$x는 123보다 작은 값입니다.";		
	} else {
		echo "$x 작지 않습니다.";
	}

?>

결과
123는 150보다 작은 값입니다.
123는 123보다 작은 값입니다.


7.6 증가/감소 연산자


증가/감소 연산자란 변수와 연산자를 결합하여 일정한 수를 증가 또는 감소하는 특수한 연산 처리입니다. 

증가/감소 연산자는 C 언어와 같은 스타일 언어들은 대부분 적용되는 연산자입니다.


|문법|
변수명 연산자
or
연산자 변수명


7.6.1 후순위 증가
후순위 증가 연산자란 연산자 기호가 변수명 뒤쪽에 있는 경우를 말합니다. 대표적으로 가장 많이 사용하는 타입이기도 합니다.  

 

$i++은 $i = $i + 1과 같은 의미입니다.
즉 변수명 뒤에 붙은 ++ 기호는 변수에 1을 더한다는 의미입니다.

예제 파일) inc-01.php
<?php
	$i = 0;
	echo "연산자 실행 전 ";
	echo "i = $i <br>";

	echo "연산자 실행 후 ";
	$i++;
	echo "i = $i <br>";
?>

결과
연산자 실행 전 i = 0
연산자 실행 후 i = 1 

증가 값이 1 이외의 설정 방법은 변수명 += 증가값;으로 작성하면 됩니다.

$i += 2;	// 2씩 증가합니다.
$i += 5;	// 5씩 증가합니다.
$i += 10;	// 10씩 증가합니다.

예제 파일) inc-02.php
<?php
	$i = 0;
	echo "연산자 실행 전 ";
	echo "i = $i <br>";

	echo "연산자 2 실행 후 ";
	$i += 2;
	echo "i = $i <br>";

	echo "연산자 3 실행 후 ";
	$i += 3;
	echo "i = $i <br>";

	echo "연산자 10 실행 후 ";
	$i += 10;
	echo "i = $i <br>";
?>

결과
연산자 실행 전 i = 0
연산자 2 실행 후 i = 2
연산자 3 실행 후 i = 5
연산자 10 실행 후 i = 15 


7.6.2 후순위 감소
++ 값이 1씩 증가하는 방식이라면, --는 1씩 감소합니다.

$i-- 은 $i = $i - 1 과 같은 의미입니다.
즉 변수명 뒤에 붙은 -- 기호는 변수에 1을 감소한다는 의미입니다.

예제 파일) inc-03.php
<?php
	$i = 0;
	echo "연산자 실행 전 ";
	echo "i = $i <br>";

	echo "연산자 실행 후 ";
	$i--;
	echo "i = $i <br>";
?>

결과
연산자 실행 전 i = 0
연산자 실행 후 i = -1 

증가 값이 1 이외의 설정 방법은 변수명 -= 증가값;으로 작성하면 됩니다.

$i -= 2;		// 2씩 감소합니다.
$i -= 5;		// 5씩 감소합니다.
$i -= 10;	// 10씩 감소합니다.

예제 파일) inc-04.php
<?php
	$i = 0;
	echo "연산자 실행 전 ";
	echo "i = $i <br>";

	echo "연산자 2 실행 후 ";
	$i -= 2;
	echo "i = $i <br>";

	echo "연산자 3 실행 후 ";
	$i -= 3;
	echo "i = $i <br>";

	echo "연산자 10 실행 후 ";
	$i -= 10;
	echo "i = $i <br>";
?>

결과
연산자 실행 전 i = 0
연산자 2 실행 후 i = -2
연산자 3 실행 후 i = -5
연산자 10 실행 후 i = -15 


7.6.3 선순위 증가
증가 연산자의 선순위와 후순위의 차이점은 증가 값의 변화가 변수 사용 전에 변경이 되는지 사용 후에 변경이 되는지의 차이입니다.

 

예제 파일) inc-05.php
<?php
	echo "후순의 증가 <br>";
	$i = 0;
	echo $i++;
	echo "<br>";
	echo $i++;

	echo "<br>";
	echo "선순의 증가 <br>";
	
	$j = 0;
	echo ++$j;
	echo "<br>";
	echo ++$j;

?>

결과
후순의 증가
0
1
선순의 증가
1
2

위의 예를 보면 후순위 증가 방식은 $i의 값을 한 번 사용하고 ++로 1의 값이 증가합니다.
따라서 첫 번째 출력은 0이 출력되고 나서 1이 증가됩니다.

반면에 선순위 방식은 $i 앞에 ++가 붙었기 때문에 $i를 사용하기 전에 1을 증가 후 변수의 값이 사용됩니다.

7.6.4 선순위 감소
선순위 감소 또한 -- 값이 변수명 앞뒤 위치에 따라서 감소 값의 적용 차이가 발생합니다.

 예제 파일) inc-06.php
<?php
	echo "후순의 감소 <br>";
	$i = 0;
	echo $i--;
	echo "<br>";
	echo $i--;
	echo "<br>";
	echo $i;

	echo "<br>";
	echo "선순의 감소 <br>";
	
	$j = 0;
	echo --$j;
	echo "<br>";
	echo --$j;
	echo "<br>";
	echo $j;

?>

결과
후순의 감소
0
-1
-2
선순의 감소
-1
-2
-2

위의 예제를 보면 후순위일 때는 변수를 참조 후에 값이 변경됩니다. 먼저 0을 출력 후 -1로 변경되고, -1로 출력 후 -2로 변경됩니다. 따라서 마지막 세 번째 출력도 -2가 출력됩니다.

선순위일 때는 먼저 값이 변경되어 -1이 출력되고, 두 번째도 값이 변경된 후에 -2가 출력됩니다. 그래서 마지막 세 번째는 그냥 값의 변경됨 없이 -2가 출력됩니다.


7.6.5 복합 연산
++ 는 += 2 와 값이 증가 값을 변경할 수 있었습니다. 

++ 와 -- 이외에,

*=	$a = $a * 값;
/=	$a = $a / 값;
%=	$a = $a % 값;

형태를 이용하여 다른 산술 연산자와 결합하여 처리할 수도 있습니다.


7.7 논리 연산자

컴퓨터의 디지털 논리 회로 and와 or의 처리 로직을 프로그램에도 적용할 수 있습니다.

기존 모든 연산자는 단일 연산 후 결과를 참(true)과 거짓(false)로 판별할 수 있었습니다. 하지만 두 가지의 조건을 같이 판별을 하고자 할 때 논리 연산자를 이용하여 두 가지의 조건을 결합할 수 있습니다.


7.7.1 AND 논리
논리 결합 AND는 좌측의 조건과 우측의 조건이 동시에 참(true)인지를 확인합니다. 만일 두 개의 값이 참(true)이면 참(true) 결과를 반환합니다. 둘 중에 하나만이라도 거짓(false)이면 거짓(false)을 반환합니다.

AND는 논리 결과값을 곱셈하는 것과 같습니다.

$result = true * false * true;
즉 1 * 0 * 0은 0 이기 때문에 거짓(false)이 됩니다.

$result = true * true * true;
즉 1 * 1 * 1은 1이기 때문에 참(true)이 됩니다. 

프로그램 언어에서는 AND 연산을 &&로 표시합니다.

예제 파일) logic-01.php
<?php
	$x = true;
	$y = true;
	$z = false;

	if ($x && $y) {
		echo "x && y = true <br>";
	} else {
		echo "x && y = false <br>";
	}

	if ($x && $y && $z) {
		echo "x && y && z = true <br>";
	} else {
		echo "x && y && z = false <br>";
	}
?>

결과
x && y = true
x && y && z = false 


7.7.2 OR 논리
논리 결합 OR는 좌측의 조건과 우측 두 개 중 참(true)인 값이 있는지를 확인합니다. 둘 중에 하나만이라도 참(true)이면 참(true)을 반환합니다.

OR 는 논리 결과값을 덧셈하는 것과 같습니다.

$result = true + false + true;
즉 1  + 0 + 1은 0보다 크기 때문에 1과 같은 참(true)이 됩니다.

$result = false * false * false;
즉 0 + 0 + 0은 0이기 때문에 거짓(false)이 됩니다. 

프로그램 언어에서는 OR 연산을 ||로 표시합니다.

예제 파일 logic-02.php
<?php
	$x = false;
	$y = false;
	$z = true;

	if ( $x || $y ) {
		echo "x || y = true <br>";
	} else {
		echo "x || y = false <br>";
	}

	if ( $x || $y || $z) {
		echo "x || y || z = true <br>";
	} else {
		echo "x || y || z = false <br>";
	}
?>

결과
x || y = false
x || y || z = true 


7.7.3 XOR 논리

XOR는 배타적 OR라고 불립니다.

xor는 두 개의 조건이 같으면 거짓(false)을 출력하고, 두 개의 값이 서로 다르면 참(true)을 출력합니다.

예제 파일 logic-03.php
<?php
	$x = false;
	$y = false;
	$z = true;

	if ( $x xor $y ) {
		echo "x xor y  = true 두 개의 논리가 틀립니다.<br>";
	} else {
		echo "x xor y = false 두 개의 논리가 같습니다.<br>";
	}

	if ( $x xor $z) {
		echo "x xor z = true 두 개의 논리가 틀립니다.<br>";
	} else {
		echo "x xor z = false 두 개의 논리가 같습니다.<br>";
	}
?>

결과
x xor y = false 두 개의 논리가 같습니다.
x xor z = true 두 개의 논리가 틀립니다.


7.7.4 NOT 논리
NOT은 논리 값을 반대의 값으로 변경합니다. 즉 참(true)은 거짓(false)으로, 거짓(false)은 참(true)으로 변경됩니다.

NOT은 변수명 앞에 느낌표 !로 사용합니다.

예제 파일 logic-04.php
<?php
	$x = true;

	if ($x) {
		echo "x는 참입니다.";
	} else {
		echo "x는 거짓입니다.";
	}

	echo "<br>";

	if (!$x) {
		echo "x는 참입니다.";
	} else {
		echo "x는 거짓입니다.";
	}

?>

결과
x는 참입니다.
x는 거짓입니다.


7.8 비트 연산

비트 연산은 정수의 특정 비트를 논리 기호를 통해 연산할 수 있습니다.

변수는 한 개의 바이트 또는 2개, 4개의 바이트로 구성됩니다. 또한 한 개의 바이트는 8개의 비트로 구성되어 있습니다.

이렇게 변수를 비트 단위로 분리하여 두 값을 비트 단위로 and, or, xor, not 연산을 하는 방법입니다.

연산하고자 하는 값이 문자일 경우에는 ASCII 값으로 처리하여 비트 연산을 하게 됩니다.

7.8.1 or 연산

예제 파일 logic-05.php
<?php
	$a = 0x02;
	echo "a값 = ".$a."<br>";

	$a |= 0x01;
	echo "a값 = ".$a."<br>";
?>

결과
a값 = 2
a값 = 3

위의 예제는 or 비트 연산의 예입니다.
$a는 16진수 헥사(hexa) 값으로 2(0x02)로 저장되어 있습니다. 0x02를 2진수 비트로 풀어보면 다음과 같습니다.

이진수 
0	0	0	0	0	0	1	0
와 
0	0	0	0	0	0	0	1
을
or( | ) 연산을 비트별로 하게 되면 
0	0	0	0	0	0	1	1
이 됩니다.  

이 값은 헥사(hexa) 값으로 0x03, 즉 3의 값이 됩니다.

7.8.2 and 연산 
다음은 AND 비트 연산의 예입니다.

예제 파일 logic-06.php
<?php
	$a = 0x03;
	echo "a값 = ".$a."<br>";

	$a &= 0x02;
	echo "a값 = ".$a."<br>";
?>

결과
a값 = 3
a값 = 2

변수 $a는 16진수 헥사(hexa) 값으로 3(0x03)로 저장되어 있습니다. 0x03를 2진수 비트로 풀어보면 다음과 같습니다.

A는 0000 0011

와 0x02 과 and ( & ) 연산을 비트별로 하게 되면 

000 0010

연산값은= 0000 0010 이 됩니다. 

이 값은 헥사(hexa) 값으로 0x02, 즉 2의 값이 됩니다.


7.8.3 xor 연산
배타적 연산 xor는 같은 비트는 false, 다른 비트는 true를 반환합니다.

예제 파일 logic-07.php
<?php
	// 2진법으로 값을 설정합니다.
	$a = 0b00000011;
	$b = 0b00001111;
	printf("a = %02x <br>",$a);
	printf("b = %02x <br>",$b);

	$xor = $a ^ $b;
	printf("a^b = %02x <br>",$xor);
?>


결과
a = 03
b = 0f
a^b = 0c 

위 예제는 

A는 = 0 0 0 0  0 0 1 1
B는 = 0 0 0 0  1 1 1 1 
----------------------------
XOR  0 0 0 0  1 1 0 0

으로 연산되어 0x0c가 출력됩니다.


7.8.4 비트 시프트 연산
헥사 값으로 표시된 정수 값들은 비트 시프트 연산을 할 수 있습니다. 비트 시프트란 전체적인 비트를 좌측으로 한 단계씩 이동하거나, 우측으로 한 단계씩 이동할 수 있습니다. 

좌측 시프트
<< 기호는 좌측 시프트 연산 기호입니다. << 뒤에 시프트할 비트 개수를 입력하면 됩니다.

1은 헥사 값으로 0x01입니다. 2진법으로는 0000 0001입니다.
이 값을 좌측으로 모두 하나씩 시프트한다고 하면 0000 0010이 됩니다. 즉 값은 2로 변경이 됩니다. 좌측으로 시프트를 하면 2를 곱한 값과 같습니다. 

우측 시프트
>>기호는 우측 시프트 연산 기호입니다. >> 뒤에 시프트할 비트 개수를 입력하면 됩니다.

우측 시프트는 좌측 시프트와 반대로 우측으로 비트를 하나씩 이동합니다. 즉, 값을 2로 나눈 값으로 출력됩니다.

예제 파일 logic-08.php
<?php
	// 시프트 연산 예제
	
	$a = 0x01;
	printf("a = %02x <br>",$a);

	// 좌측 시프트는 * 2
	$a = $a<<1;
	printf("a = %02x <br>",$a);

	// 좌측 시프트는 * 2
	$a = $a<<2;
	printf("a = %02x <br>",$a);

	// 우측 시프트는 / 2
	$a = $a>>1;
	printf("a = %02x <br>",$a);

	// 우측 시프트는 / 2
	$a = $a>>2;
	printf("a = %02x <br>",$a);

?>

결과
a = 1
a = 2
a = 8
a = 4
a = 1

시프트 연산은 산술 연산보다 빠른 곱셈 2와 나눗셈 2를 연산할 수 있습니다. 이는 연산 처리의 로직 논리가 다르기틀리기 때문입니다.

시프트 연산 시 컴퓨터의 운영 시스템에 따라 차이가 있을 수 있습니다. 비트 수가 넘어가면 오버플로가 발생하여 예상과 다른 값을 출력할 수 있습니다.


7.9 문자열 연산

지금까지 많은 예제 중에서 화면 출력 시 점(.) 기호를 많이 봤을 것입니다. PHP에서는 두 개의 문자열을 결합할 수 있는 연산자를 지원합니다. 다른 언어에서는 좀 더 직관적인 덧셈(+) 기호를 쓰기도 하지만 PHP에서는 점(.) 연산자를 사용합니다.

|문법|
$text = $txt1 . $txt2 

점은 두 개의 문자열을 연결하는 기능을 합니다. 
예제 파일 string-0601.php
<?php
	$a = "hello";
	$b = "world!";

	// 문자열을 바로 결합니다.
	echo "hello " . "world!";
	echo "<br>";

	// 변수와 문자열을 결합합니다.
	echo $a . " world!";
	echo "<br>";
	
	// 변수와 변수를 결합합니다.
	echo $a . $b;
	echo "<br>";
?>

결과
hello world!
hello world!
helloworld!

점 연산자는 문자열 데이터를 바로 연결할 수도 있으며, 변수와 같이 혼용하여 연결할 수도 있습니다.

또한 이전에 복합 연산 방식과 비슷하게 .= 방식으로 기존의 문자열에 새로운 문자열을 결합할 수도 있습니다. 새로운 문자열은 기존 문자열 맨 뒤에 추가로 연결됩니다.

$text .=  $txt2 


예제 파일 string-0702.php
<?php	
	$a = 'a';

	for($i=0;$i<10;$i++)
	{
		$string .= $a++;
		echo $string . "<br>";
	}
?>

결과
a
ab
abc
abcd
abcde
abcdef
abcdefg
abcdefgh
abcdefghi
abcdefghij

위의 예를 보면 $string 변수에 알파벳을 하나씩 늘려가면서 추가하는 예제입니다. 
.= 연산자를 통해 알파벳 한 글자 한 글자를 결합하면서 화면에 출력합니다.


7.10 배열 연산

배열 변수도 앞에서 설명한 연산자 중 일부 몇 개는 배열의 연산자로 사용이용할 수 있습니다.

7.10.1 배열 결합
산술 연산자 덧셈(+)을 통해 두 개의 배열을 결합할 수 있습니다.

예제 파일 arrayop-01.php
<?php
	$x = array("red" => "빨강", "green" => "녹색");  
	$y = array("blue" => "파랑", "yellow" => "노랑");  
	
	// 두 개의 배열을 결합니다.
	print_r($x + $y); 
?> 

결과
Array ( [red] => 빨강 [green] => 녹색 [blue] => 파랑 [yellow] => 노랑 ) 

위의 예제는 두 개의 배열을 결합니다. 간단한 덧셈 연산 기호로 배열을 결합할 수 있습니다.

7.10.2 배열 비교
== 비교 연산자를 이용하여 두 개의 배열 값이 같은지를 비교할 수 있습니다.

예제 파일 arrayop-01.php
<?php
	$x = array("red" => "빨강", "green" => "녹색");  
	$y = array("blue" => "파랑", "yellow" => "노랑"); 

	// 두 개의 배열이 같은지 확인
	var_dump($x == $y);

	echo "<br>";
	$z = array("red" => "빨강", "green" => "녹색");
	var_dump($x == $z);	
?>

결과
bool(false)
bool(true)

위의 예제는 두 개의 배열의 값이 서로 같은지를 비교합니다.

7.10.3 배열 형태 비교
=== 는 두 개의 변수 값이 같은지와 형태까지 같이 비교할 수 있습니다. 배열 또한 ===를 통해 두 값을 비교할 수 있습니다.

2개의 배열의 키/값과 배열의 순서, 형태까지 모두 일치하는지를 판별할 수 있습니다.

예제 파일 arrayop-03.php
<?php
	$x = array("red" => "빨강", "green" => "녹색");  
	$y = array("red" => "빨강", "green" => "녹색");
	var_dump($x === $y);

	echo "<br>";

	$z = array("green" => "녹색", "red" => "빨강");
	var_dump($x === $z);
	
?> 

결과
bool(true)
bool(false) 

위의 예제는 배열의 형태까지 비교할 수 있는 연산자 예입니다. ===가 형태까지 비교 판단을 하는 연산자라는 것을 학습했다면 좀 더 이해하기 쉬울 것입니다.

7.10.4 배열이 상호 다름
부정 연산 기호를 통해 두 개의 배열이 같지 않은지를 판별 할 수 있습니다.

예제 파일 arrayop-04.php
<?php
	$x = array("red" => "빨강", "green" => "녹색");  
	$y = array("blue" => "파랑", "yellow" => "노랑");  
	var_dump($x != $y);
?> 

결과
bool(true)


7.11 Spaceship 연산자

기존의 비교연산자는 두 개의 값을 비교하여 참(1)과 거짓(0)으로 논리 결과를 반환했습니다.

PHP 7.x로 업그레이드되면서 두 개의 값이 큰지, 작은지, 같은지를 한 번에 비교하는 스페이스쉽  연산자를 새롭게 지원합니다.

스페이스 연산자는 <=>로 표시가 되는데 그 모양이 우주선과 같이 보여서 스페이스 연산자라고 명칭하게 되었습니다.

PHP 7.x 이전에 스페이스 연산과 같은 처리를 하기 위해서는 다음과 같은 함수를 만들어서 사용해야 했습니다.
 
function _Spaceship($a,$b){

	if ($a == $b) return 0;
	else if($a<$b) return -1;
	else if($a>$b) return 1; 

}

즉 입력된 2개의 값을 3번의 조건문을 통해 처리했습니다.

예제 파일 space-01.php
<?php
// 정수
	echo "정수<br>";
	echo "1 <=> 1 = ";
	echo 1 <=> 1; // 0
	echo "<br>";
	echo "1 <=> 2 = ";
	echo 1 <=> 2;
	echo "<br>"; // -1
	echo "2 <=> 1 = ";
	echo 2 <=> 1;
	echo "<br>"; // 1


	// 실수
	echo "<br>";
	echo "실수<br>";
	echo "1.5 <=> 1.5 = ";
	echo 1.5 <=> 1.5;
	echo "<br>"; // 0
	echo "1.5 <=> 2.5 = ";
	echo 1.5 <=> 2.5;
	echo "<br>"; // -1
	echo "2.5 <=> 1.5 = ";
	echo 2.5 <=> 1.5;
	echo "<br>"; // 1
 
	// 문자열
	echo "<br>";
	echo "문자열<br>";
	echo "a <=> a = ";
	echo "a" <=> "a";
	echo "<br>"; // 0
	echo "a <=> b = ";
	echo "a" <=> "b";
	echo "<br>"; // -1
	echo "b <=> a = ";
	echo "b" <=> "a";
	echo "<br>"; // 1
?>

결과
정수
1 <=> 1 = 0
1 <=> 2 = -1
2 <=> 1 = 1

실수
1.5 <=> 1.5 = 0
1.5 <=> 2.5 = -1
2.5 <=> 1.5 = 1

문자열
a <=> a = 0
a <=> b = -1
b <=> a = 1


지금까지 다양한 연산자와 예제를 통해 알아봤습니다. 연산자는 프로그램을 만드는 가장 기본적인 문법과 기능입니다.

연산자를 잘 구분하고, 문법을 습득하는 것은 앞으로 프로그램 코딩을 하면서 문법적인 오류를 줄이는 중요한 기초가 됩니다. 차근차근 기초부터 학습을 하면 좀 더 향상된 코드를 만들 수 있을 것입니다.


7.12 오류 제어 연산자
PHP는 오류제어 연산자 @를 지원합니다.

오류 제어 연산자를 코드 앞에 붙여서 사용하면 발생된 오류 메시지를 무시하게 됩니다. 오류 메시지를 숨기는 이유는 접속자에게 오류 코드를 감추어 보안의 유효성을 높이는 효과가 있습니다.

예제 파일 opr-01.php
<?php
	// php.ini의 수정 없이 화면에 에러 발생 시 출력할 수 있습니다.
	error_reporting(E_ALL);
	ini_set("display_errors", 1);

	// test.php는 실제 존재하지 않는 파일입니다.  
	@include('test.php'); 
?>

화면 출력  
 

위의 예제는 실제 존재하지 않는 파일을 include하는 예제입니다. 실행 시 파일에 대한 오류 메시지를 출력합니다.

@include('test.php'); 형태로 @를 앞에 붙여서 실행하면 오류가 발생해도 화면에 출력하지 않습니다.

@ 연산자를 사용할 때는 주의해야 합니다. 만일, 잘못된 사용으로 인해 오류가 출력하지 않을 때 프로그램의 문제를 해결하기란 매우 어렵습니다.

@로 인하여 오류가 발생한 경우는 별도로 오류 메시지를 $php_errormsg 변수에 저장해 놓습니다.

예제 파일 opr-02.php
<?php
	// php.ini의 수정 없이 화면에 에러 발생 시 출력할 수 있습니다.
	error_reporting(E_ALL);
	ini_set("display_errors", 1);

	$my_file = @file ('testing.txt') or die($php_errormsg." = 오류를 출력합니다.");
?>


결과  
Notice: Undefined variable: php_errormsg in C:\php-7.1.4-Win32-VC14-x86\jinyphp\opr-02.php on line 6
= 오류를 출력합니다.

오류 발생 시 $php_errormsg 변수는 바로 사용해야 합니다. 만일 여러 번의 오류가 발생할 경우  $php_errormsgs는 새로운 오류 메시지로 덮어쓰게 됩니다.

$php_errormsgs를 사용하기 위해서는 PHP의 환경 설정 php.ini 에서

track_error = on

상태일 때만 가능합니다.

지금까지 다양한 연산자와 예제를 통해 알아봤습니다. 연산자는 프로그램을 만드는 가장 기본적인 문법과 기능입니다.

연산자를 잘 구분하고, 문법을 습득하는 것은 앞으로 프로그램 코딩을 하면서 문법적인 오류를 줄이는 중요한 기초가 됩니다. 차근차근 기초부터 학습을 하면 좀 더 향상된 코드를 만들 수 있을 것입니다.

