---
layout: php
---
## 7.8 비트 연산
<hr>

비트 연산은 정수의 특정 비트를 논리 기호를 통해 연산할 수 있습니다.  

변수는 한 개의 바이트 또는 2개, 4개의 바이트로 구성됩니다. 또한 한 개의 바이트는 8개의 비트로 구성되어 있습니다.  

이렇게 변수를 비트 단위로 분리하여 두 값을 비트 단위로 and, or, xor, not 연산을 하는 방법입니다.  

연산하고자 하는 값이 문자일 경우에는 ASCII 값으로 처리하여 비트 연산을 하게 됩니다.  

<br>

### 7.8.1 or 연산
<hr>

예제 파일 logic-05.php
```php
<?php
	$a = 0x02;
	echo "a값 = ".$a."<br>";

	$a |= 0x01;
	echo "a값 = ".$a."<br>";
?>
```

결과
```
a값 = 2
a값 = 3
```

위의 예제는 or 비트 연산의 예입니다. 
$a는 16진수 헥사(hexa) 값으로 2(0x02)로 저장되어 있습니다. 0x02를 2진수 비트로 풀어보면 다음과 같습니다.  

이진수  
0	0	0	0	0	0	1	0  
와  
0	0	0	0	0	0	0	1  
을  
or( | ) 연산을 비트별로 하게 되면  
0	0	0	0	0	0	1	1  
이 됩니다.  

이 값은 헥사(hexa) 값으로 0x03, 즉 3의 값이 됩니다.  

<br>

### 7.8.2 and 연산 
<hr>

다음은 AND 비트 연산의 예입니다.  

예제 파일 logic-06.php
```php
<?php
	$a = 0x03;
	echo "a값 = ".$a."<br>";

	$a &= 0x02;
	echo "a값 = ".$a."<br>";
?>
```

결과
```
a값 = 3
a값 = 2
```

변수 $a는 16진수 헥사(hexa) 값으로 3(0x03)로 저장되어 있습니다. 0x03를 2진수 비트로 풀어보면 다음과 같습니다.  

A는 0000 0011  

와 0x02 과 and ( & ) 연산을 비트별로 하게 되면   


연산값은 0000 0010 이 됩니다.  

이 값은 헥사(hexa) 값으로 0x02, 즉 2의 값이 됩니다.  

<br>

### 7.8.3 xor 연산
<hr>

배타적 연산 xor는 같은 비트는 false, 다른 비트는 true를 반환합니다.  

예제 파일 logic-07.php
```php
<?php
	// 2진법으로 값을 설정합니다.
	$a = 0b00000011;
	$b = 0b00001111;
	printf("a = %02x <br>",$a);
	printf("b = %02x <br>",$b);

	$xor = $a ^ $b;
	printf("a^b = %02x <br>",$xor);
?>
```

결과
```
a = 03
b = 0f
a^b = 0c 
```

위 예제는 
```
A는 = 0 0 0 0  0 0 1 1
B는 = 0 0 0 0  1 1 1 1 
----------------------------
XOR  0 0 0 0  1 1 0 0
```

으로 연산되어 0x0c가 출력됩니다.  

<br>

### 7.8.4 비트 시프트 연산
<hr>

헥사 값으로 표시된 정수 값들은 비트 시프트 연산을 할 수 있습니다. 비트 시프트란 전체적인 비트를 좌측으로 한 단계씩 이동하거나, 우측으로 한 단계씩 이동할 수 있습니다.  

* 좌측 시프트  
<< 기호는 좌측 시프트 연산 기호입니다. << 뒤에 시프트할 비트 개수를 입력하면 됩니다.  

1은 헥사 값으로 0x01입니다. 2진법으로는 0000 0001입니다.  
이 값을 좌측으로 모두 하나씩 시프트한다고 하면 0000 0010이 됩니다. 즉 값은 2로 변경이 됩니다. 좌측으로 시프트를 하면 2를 곱한 값과 같습니다.  

* 우측 시프트  
>>기호는 우측 시프트 연산 기호입니다. >> 뒤에 시프트할 비트 개수를 입력하면 됩니다.  

우측 시프트는 좌측 시프트와 반대로 우측으로 비트를 하나씩 이동합니다. 즉, 값을 2로 나눈 값으로 출력됩니다.  

예제 파일 logic-08.php
```php
<?php
	// 시프트 연산 예제
	
	$a = 0x01;
	printf("a = %02x <br>",$a);

	// 좌측 시프트는 * 2
	$a = $a<<1;
	printf("a = %02x <br>",$a);

	// 좌측 시프트는 * 2
	$a = $a<<2;
	printf("a = %02x <br>",$a);

	// 우측 시프트는 / 2
	$a = $a>>1;
	printf("a = %02x <br>",$a);

	// 우측 시프트는 / 2
	$a = $a>>2;
	printf("a = %02x <br>",$a);

?>
```

결과
```
a = 1
a = 2
a = 8
a = 4
a = 1
```

시프트 연산은 산술 연산보다 빠른 곱셈 2와 나눗셈 2를 연산할 수 있습니다. 이는 연산 처리의 로직 논리가 다르기 때문입니다.  

시프트 연산 시 컴퓨터의 운영 시스템에 따라 차이가 있을 수 있습니다. 비트 수가 넘어가면 오버플로가 발생하여 예상과 다른 값을 출력할 수 있습니다.  

<br><br>