---
layout: default
title: Strategy
subtitle: "patterns"

tree: /php
---

### 스트래티지 패턴
---

스트레이지 패턴은 객체를 통하여 기능을 구현할때 객체의 추상적인 접근점을 생헝하는 패턴입니다. 추상적인 접근이란 인터페이스를 말하는데, 이러한 인터페이스를 이용하여 적용하고자 하는 객체를 서료 교환하여 처리할 수 있는 패턴을 말합니다.

예를 들면, 하나의 프로젝트가 동일한 인터페이스를 가지는 여러 기능들이 존재할 수 있습니다. 각각의 기능들은 인터페이스를 통하여 규격을 정하였기 때문에 호출하여 사용하는 방법은 동일 할 것입니다. 물론, 각각의 기능들의 내부 기능은 다르게 구현이 될 것입니다. 이렇게 인터페이스로 정의된 기능들을 호출할때 서료 교환하여 복수의 기능을 호출 처리 하는 패턴을 말합니다. 

다른 패턴들은 객체가 확장, 변형되면서 바뀌어 가는 형태의 패턴이었습니다. 스트래지티 패턴은 객체가 변경경되는 것이 아니라 하나의 객체가 다른 종류의 행동객체로 되는 패턴입니다.

<br>

### 분류
---
스트레티지 패턴은 GOF의 행위 패턴으로 분류 됩니다.

### 목적
---
스트레이트 패턴을 사용시 적용되는 알고리즘은 캡슐화 처리 됩니다. 갭슐화된 알고리즘은 상황에 맞게 교체되어 사용되어 집니다.

여러개의 알고리즘을 동적으로 교체하여 사용이 가능합니다. 또한 새로운 확장이 쉽게 도와 줍니다.



### 기본실습
---
기본 코드를 통하여 스트레이지 패턴의 동작을 이해해 보도록 하겠습니다.

스트레이지 패턴을 좀더 쉽게 이해하기 위해서 게임을 예를 들어 알아 보도록 하겠습니다. RPG게임 캐릭터가 있습니다. 캐릭터는 여러 무기들이 존재하고, 이를 상대방 캐릭터에게 공격을 하게 됩니다.

스트래티지 패턴을 학습하기 위해서는 먼저 PHP이 인터페이스의 이해가 필요로 합니다.
무기에 대한 인터페이스를 하나 생성합니다. `Weapon` 인터페이스는 공격을 실행하는 하나의  `attact()` 메소드가 존재합니다.

sample_01/Weapon.php
```php
<?php
/**
 * 무기에 대한 인터페이스를 선언합니다.
 */
interface Weapon
{
    public function attact();
    
}
```

그리고 `Weapon` 인터페이스를 적용한 무기 클래스를 생성합니다. A개발자는 `칼` 무기에 대한 클래스를 개발합니다.

sample_01/Knife.php
```php
<?php
/**
 * 무기 인터페이스를 적용하여 객체의 실체 코드 구현을 작성합니다.
 */
class Knife implements Weapon
{
    public function attact()
    {
        print "칼 공격합니다.";
        echo "\n";
    }
}
```

`Weapon` 인터페이스를 적용한 또다른 무기 클래스를 생성합니다. B개발자는 `총` 무기에 대한 클래스를 개발합니다.

sample_01/Gun.php
```php
<?php
/**
 * 무기 인터페이스를 적용하여 객체의 실체 코드 구현을 작성합니다.
 */
class Gun implements Weapon
{
    public function attact()
    {
        print "총을 발포합니다.";
        echo "\n";
    }
}
```

`Weapon` 인터페이스를 응용하여 여러개의 객체 클래스를 생성을 할 수 있습니다.

이번에는 캐릭터 하나를 생성합니다. C개발자는 `캐릭터` 무기에 대한 클래스를 개발합니다.
캐릭터가 무기를 선택할 수 있는 상황들을 스트레이트 패턴으로 적용해 볼 수 있습니다.

sample_01/Charactor.php
```php
<?php
/**
 * 객체를 딜리게이트 처리하여 호출합니다.
 */
clas
class Charactor
{
    // 추상적인 접근점
    private $_delegate;

    // 무기 교환 패턴
    public function setWeapon(Weapon $weapon)
    {
        echo "무기를 교환합니다.<br>";
        $this->_delegate = $weapon;
    }

    public function attact()
    {
        if ($this->_delegate == NULL) {
            // 무기가 선택되지 않은 경우
            echo "맨손 공격합니다.<br>";
        } else {
            // 델리게이트
            $this->_delegate->attact();
        }        
    }
}
```

캐릭터 클래스는 두개의 메소드를 가지고 있습니다. `setWeapon()` 메소드는 매개변수로 전달받은 클래스의 인스턴스를 내부 프로퍼티 값으로 설정을 합니다. 입력받은 객체를 내부 변수를 통하여 추상적인 접근점을 만들어 기능을 위임처리 할 수 있습니다.

A,B 개발자가 만들고 있는 무기 캐릭터에 대해서 개발자 C는 상관하지 않고, 캐틱터 객체를 생성할 수 있습니다. 캐릭터에서 필요로 하는 무기 클래스들은 `$_delegate` 프로퍼티을 통하여 위임처리 할 수 있기 때문입니다.

캐릭터 클래스이 `attact()` 메소드는 위임된 무기 클래스의 `attact()` 메소드를 다시 호출하게 됩니다.

이렇게 생성한 전략패턴을 프로젝트로 출력해 보도록 합니다.

sample_01/index.php
```php
<?php
    // 인터페이스
    require("Weapon.php");
    
    // 무기구현
    require("Gun.php");
    require("Knife.php");
    
    require("Charactor.php");

    $obj = new Charactor;
    $obj->attact();

    // 무기교환
    $obj->setWeapon(new Knife);
    $obj->attact();

    // 무기교환
    $obj->setWeapon(new Gun);
    $obj->attact();
```

매소드의 매개변수 인자 값으로 클래스의 객체를 전달 할 수 있습니다. 클래스의 객체를 미리 변수에 담아 전달을 할 수 도 있지만, 직접 new 키워드를 통하여 객체를 전달 할 수 있습니다. 

```php
$w = new Knife;
$obj->setWeapon($w);
unset($w);
```

위와 같이 코드를 처리를 할 수도 있겠지만, new 키워드로 생성전달하게 되면 새로운 변수를 생성 저장하지 않기 때문에 메모리를 효율적으로 이용할 수 있습니다.

위의 코드를 실행하면 다음과 같습니다.

```php
$ php index.php
맨손 공격합니다.
무기를 교환합니다.
칼 공격합니다.
무기를 교환합니다.
총을 발포합니다.
```

캐릭터에 대한 객체를 하나 실행합니다. 그리고 캐릭터의 `attact()` 매소드를 실행합니다. 

`setWeapon()` 메소드를 이용하여 무기 객체에 대한 인스턴스를 생성하여 전달합니다. `setWeapon()` 메소드는 전달받은 무기 인스턴스를 딜리게이션 처리 할 수 있도록 내부 프로퍼티에 객체를 저장합니다. 그리고 캐틱터의 `attact()` 매소드를 다시 실행합니다. 

캐틱터의 `attact()` 매소드는 딜리케이트된 무기 인스턴스가 있는 경우에는 무기 인스턴스의 `attact()` 매소드를 호출하게 됩니다. 즉, 우리는 `Weapon`이라는 인터페이슬 먼저 선언하고, 이를 통하여 유사한 다양한 객체를 생성할 수 있었습니다. 또한, 이렇게 생성한 객체의 인스턴스를 매개변수 인자로 전달하여 클래스의 인스턴스를 자유롭게 변경을 하면서 처리를 할 수 있습니다.

<br>

### 적용사례2
---
스트레이트 패턴은 다양한 알고리즘을 적용하여 처리할 때 매우 유용합니다. 대표적으로 정렬은 다양한 알고리즘을 가지고 있습니다. 버블정렬, 쉘정렬, 퀵정렬등. 즉, 문제를 해결하는 알고리즘을 변경하여 객체의 문제를 해결하는데 스트레이트 패턴은 매우 유용합니다.

### 적용사례3
---
만일 통신 프로토콜을 변경하는 시스템에서도 스트레이트 패턴을 적용해 볼 수 있습니다. 모바일로 접속시에 LTE를 프로토콜을 사용할지, Wifi를 사용할지등의 선택또한 스트레이트 패턴으로 구현을 할 수 있습니다. 

### 정리
---
스트레이지 패턴은 실제 프로젝트에서 가장 많이 사용되는 패턴 유형중의 하나 입니다.

스트레이트 패턴이 객체의 인스턴스를 교환하여 쓸수 있는 것은 유용한 부분이 있습니다.
하지만 실행 도중에 프로그램 코드에서 사용되는 객체의 수가 증가 됩는 단점이 있습니다.
<br>
